# 📚 5장: 객체지향 프로그래밍 완전 가이드

## 🎯 학습 목표
- 클래스와 객체의 개념 이해
- 생성자와 메서드의 역할 파악
- 상속과 다형성의 원리 학습
- 접근 제어 (public, protected, private) 이해
- @property 데코레이터 활용법 학습
- 객체지향 프로그래밍의 장점과 활용 사례 익히기

## 📖 핵심 개념

### 1. 클래스와 객체
**클래스 (Class)**: 객체를 만들기 위한 설계도 또는 틀
**객체 (Object)**: 클래스로부터 생성된 실제 인스턴스

**기본 구조**:
```python
class 클래스명:
    def __init__(self, 매개변수1, 매개변수2, ...):
        self.속성1 = 매개변수1
        self.속성2 = 매개변수2
    
    def 메서드명(self, 추가_매개변수):
        # 메서드 내용
        pass
```

**실제 사용 예시**:
```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def introduce(self):
        return f"안녕하세요, 저는 {self.name}이고 {self.age}세입니다."

# 객체 생성
person1 = Person("홍길동", 25)
person2 = Person("김철수", 30)

# 메서드 호출
print(person1.introduce())  # 안녕하세요, 저는 홍길동이고 25세입니다.
print(person2.introduce())  # 안녕하세요, 저는 김철수이고 30세입니다.
```

### 2. 생성자와 메서드

#### 2.1 생성자 (__init__)
**정의**: 객체가 생성될 때 자동으로 호출되는 특별한 메서드

```python
class Student:
    def __init__(self, name, student_id, grade):
        self.name = name
        self.student_id = student_id
        self.grade = grade
        print(f"{name} 학생이 생성되었습니다.")

# 객체 생성 시 생성자 자동 호출
student = Student("이영희", "2024001", "A")
```

#### 2.2 인스턴스 메서드
**정의**: 객체의 상태를 조작하거나 정보를 반환하는 메서드

```python
class BankAccount:
    def __init__(self, account_number, initial_balance=0):
        self.account_number = account_number
        self.balance = initial_balance
    
    def deposit(self, amount):
        """입금"""
        self.balance += amount
        return f"{amount}원 입금. 잔액: {self.balance}원"
    
    def withdraw(self, amount):
        """출금"""
        if amount <= self.balance:
            self.balance -= amount
            return f"{amount}원 출금. 잔액: {self.balance}원"
        else:
            return "잔액이 부족합니다."
    
    def get_balance(self):
        """잔액 조회"""
        return f"현재 잔액: {self.balance}원"

# 사용
account = BankAccount("123-456-789", 10000)
print(account.deposit(5000))  # 5000원 입금. 잔액: 15000원
print(account.withdraw(3000)) # 3000원 출금. 잔액: 12000원
print(account.get_balance())  # 현재 잔액: 12000원
```

### 3. 클래스 변수와 인스턴스 변수

#### 3.1 인스턴스 변수
- 각 객체마다 독립적으로 가지는 변수
- `self.변수명`으로 정의

#### 3.2 클래스 변수
- 모든 객체가 공유하는 변수
- 클래스 내부에서 `변수명 = 값`으로 정의

```python
class Car:
    # 클래스 변수
    total_cars = 0
    brand = "Unknown"
    
    def __init__(self, model, year):
        # 인스턴스 변수
        self.model = model
        self.year = year
        Car.total_cars += 1  # 클래스 변수 수정
    
    @classmethod
    def get_total_cars(cls):
        return cls.total_cars
    
    @classmethod
    def set_brand(cls, new_brand):
        cls.brand = new_brand

# 사용
car1 = Car("Model S", 2023)
car2 = Car("Model 3", 2024)

print(f"총 자동차 수: {Car.get_total_cars()}")  # 2
Car.set_brand("Tesla")
print(f"브랜드: {Car.brand}")  # Tesla
```

### 4. 상속 (Inheritance)
**정의**: 기존 클래스의 속성과 메서드를 새로운 클래스가 물려받는 것

**기본 문법**:
```python
class 자식클래스(부모클래스):
    def __init__(self, 매개변수들):
        super().__init__(부모클래스_매개변수들)
        # 자식클래스만의 추가 속성
```

**실제 사용 예시**:
```python
class Animal:
    def __init__(self, name, species):
        self.name = name
        self.species = species
    
    def make_sound(self):
        return "Some generic sound"
    
    def move(self):
        return f"{self.name} is moving"

class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name, "Dog")
        self.breed = breed
    
    def make_sound(self):  # 메서드 오버라이딩
        return "Woof! Woof!"
    
    def fetch(self):  # 자식클래스만의 메서드
        return f"{self.name} is fetching the ball"

# 사용
dog = Dog("멍멍이", "골든리트리버")
print(dog.make_sound())  # Woof! Woof!
print(dog.move())        # 멍멍이 is moving
print(dog.fetch())       # 멍멍이 is fetching the ball
```

### 5. 다형성 (Polymorphism)
**정의**: 같은 인터페이스를 가진 객체들이 서로 다른 방식으로 동작하는 것

```python
class Shape:
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14159 * self.radius ** 2

# 다형성 활용
shapes = [
    Rectangle(5, 3),
    Circle(4),
    Rectangle(2, 6)
]

for shape in shapes:
    print(f"면적: {shape.area()}")  # 각각 다른 방식으로 계산
```

### 6. 접근 제어

#### 6.1 Public (공개)
- 아무 접두사 없음
- 어디서든 접근 가능

#### 6.2 Protected (보호)
- 언더스코어 한 개 (`_`)
- 클래스 내부와 자식 클래스에서만 사용

#### 6.3 Private (비공개)
- 언더스코어 두 개 (`__`)
- 클래스 내부에서만 사용

```python
class BankAccount:
    def __init__(self, account_number, initial_balance=0):
        self.account_number = account_number  # Public
        self._balance = initial_balance       # Protected
        self.__pin = "1234"                   # Private
    
    def get_balance(self):
        return self._balance
    
    def __validate_pin(self, pin):  # Private 메서드
        return self.__pin == pin
    
    def withdraw(self, amount, pin):
        if self.__validate_pin(pin):
            if amount <= self._balance:
                self._balance -= amount
                return True
        return False

# 사용
account = BankAccount("123-456", 10000)
print(account.account_number)  # 접근 가능
print(account.get_balance())   # 10000
# print(account.__pin)         # 오류 발생
```

### 7. @property 데코레이터
**정의**: 메서드를 속성처럼 사용할 수 있게 해주는 데코레이터

```python
class Temperature:
    def __init__(self, celsius=0):
        self._celsius = celsius
    
    @property
    def celsius(self):
        return self._celsius
    
    @celsius.setter
    def celsius(self, value):
        if value < -273.15:
            raise ValueError("절대 영도보다 낮을 수 없습니다.")
        self._celsius = value
    
    @property
    def fahrenheit(self):
        return self._celsius * 9/5 + 32
    
    @fahrenheit.setter
    def fahrenheit(self, value):
        self.celsius = (value - 32) * 5/9

# 사용
temp = Temperature(25)
print(f"섭씨: {temp.celsius}°C")      # 25°C
print(f"화씨: {temp.fahrenheit}°F")   # 77.0°F

temp.fahrenheit = 86
print(f"섭씨: {temp.celsius}°C")      # 30°C
```

## 🔧 실습 예시

### 예제 1: 학생 관리 시스템
```python
class Student:
    def __init__(self, name, student_id, major):
        self.name = name
        self.student_id = student_id
        self.major = major
        self.grades = {}
        self.gpa = 0.0
    
    def add_grade(self, subject, grade):
        """성적 추가"""
        self.grades[subject] = grade
        self._calculate_gpa()
    
    def _calculate_gpa(self):
        """GPA 계산 (private 메서드)"""
        if self.grades:
            total_points = sum(self.grades.values())
            self.gpa = total_points / len(self.grades)
    
    def get_info(self):
        """학생 정보 반환"""
        return f"이름: {self.name}, 학번: {self.student_id}, 전공: {self.major}, GPA: {self.gpa:.2f}"

# 사용
student = Student("김파이썬", "2024001", "컴퓨터공학")
student.add_grade("수학", 90)
student.add_grade("영어", 85)
student.add_grade("과학", 92)

print(student.get_info())
```

### 예제 2: 상속을 활용한 도형 클래스
```python
class Shape:
    def __init__(self, name):
        self.name = name
    
    def area(self):
        raise NotImplementedError("서브클래스에서 구현해야 합니다.")
    
    def perimeter(self):
        raise NotImplementedError("서브클래스에서 구현해야 합니다.")

class Rectangle(Shape):
    def __init__(self, width, height):
        super().__init__("사각형")
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)

class Circle(Shape):
    def __init__(self, radius):
        super().__init__("원")
        self.radius = radius
    
    def area(self):
        return 3.14159 * self.radius ** 2
    
    def perimeter(self):
        return 2 * 3.14159 * self.radius

# 사용
shapes = [
    Rectangle(5, 3),
    Circle(4),
    Rectangle(2, 6)
]

for shape in shapes:
    print(f"{shape.name}: 면적={shape.area():.2f}, 둘레={shape.perimeter():.2f}")
```

### 예제 3: @property를 활용한 안전한 데이터 관리
```python
class Person:
    def __init__(self, name, age):
        self._name = name
        self._age = age
    
    @property
    def name(self):
        return self._name
    
    @name.setter
    def name(self, value):
        if not isinstance(value, str):
            raise ValueError("이름은 문자열이어야 합니다.")
        if len(value) < 2:
            raise ValueError("이름은 2글자 이상이어야 합니다.")
        self._name = value
    
    @property
    def age(self):
        return self._age
    
    @age.setter
    def age(self, value):
        if not isinstance(value, int):
            raise ValueError("나이는 정수여야 합니다.")
        if value < 0 or value > 150:
            raise ValueError("나이는 0-150 사이여야 합니다.")
        self._age = value
    
    @property
    def info(self):
        return f"이름: {self._name}, 나이: {self._age}세"

# 사용
person = Person("홍길동", 25)
print(person.info)

person.name = "김철수"
person.age = 30
print(person.info)

# 잘못된 값 설정 시 오류
try:
    person.age = -5
except ValueError as e:
    print(f"오류: {e}")
```

### 예제 4: 실무 활용 - 쇼핑몰 상품 관리
```python
class Product:
    def __init__(self, name, price, category):
        self.name = name
        self.price = price
        self.category = category
        self._discount = 0
        self._stock = 0
    
    @property
    def discount(self):
        return self._discount
    
    @discount.setter
    def discount(self, value):
        if 0 <= value <= 100:
            self._discount = value
        else:
            raise ValueError("할인율은 0-100 사이여야 합니다.")
    
    @property
    def final_price(self):
        return self.price * (1 - self._discount / 100)
    
    @property
    def stock(self):
        return self._stock
    
    def add_stock(self, quantity):
        if quantity > 0:
            self._stock += quantity
        else:
            raise ValueError("수량은 0보다 커야 합니다.")
    
    def sell(self, quantity):
        if quantity <= self._stock:
            self._stock -= quantity
            return True
        return False

class Electronics(Product):
    def __init__(self, name, price, brand, warranty_years):
        super().__init__(name, price, "전자제품")
        self.brand = brand
        self.warranty_years = warranty_years
    
    def get_info(self):
        return f"{self.brand} {self.name} - {self.final_price:,.0f}원 (재고: {self.stock}개, 보증: {self.warranty_years}년)"

# 사용
laptop = Electronics("노트북", 1000000, "삼성", 2)
laptop.add_stock(10)
laptop.discount = 15  # 15% 할인

print(laptop.get_info())
print(f"할인 후 가격: {laptop.final_price:,.0f}원")

if laptop.sell(2):
    print("판매 완료")
    print(f"남은 재고: {laptop.stock}개")
```

## ⚠️ 주의사항

1. **self 키워드**:
   - 모든 인스턴스 메서드의 첫 번째 매개변수
   - 객체 자신을 가리키는 참조

2. **상속 시 super() 사용**:
   - 부모 클래스의 생성자를 호출할 때 사용
   - Python 3에서는 `super().__init__()` 권장

3. **접근 제어의 한계**:
   - Python의 접근 제어는 관례적
   - 완전한 캡슐화는 아님

4. **@property 사용 시**:
   - getter와 setter를 함께 정의하는 것이 일반적
   - 복잡한 로직은 일반 메서드 사용 고려

5. **클래스 설계**:
   - 단일 책임 원칙 준수
   - 과도한 상속보다는 조합(composition) 고려

## 🎯 학습 체크리스트

- [ ] 클래스와 객체의 개념 이해하기
- [ ] 생성자와 메서드 정의하기
- [ ] 클래스 변수와 인스턴스 변수 구분하기
- [ ] 상속을 활용한 클래스 설계하기
- [ ] 메서드 오버라이딩으로 다형성 구현하기
- [ ] 접근 제어로 데이터 보호하기
- [ ] @property로 안전한 속성 관리하기
- [ ] 실무에 맞는 클래스 설계하기

## 🔗 관련 링크

- [파이썬 공식 문서 - 클래스](https://docs.python.org/3/tutorial/classes.html)
- [파이썬 공식 문서 - 상속](https://docs.python.org/3/tutorial/classes.html#inheritance)
- [이전 챕터: 고급 파이썬 기법](./04-고급파이썬기법.md)
- [다음 챕터: 데이터 분석 라이브러리](./06-데이터분석라이브러리.md)
