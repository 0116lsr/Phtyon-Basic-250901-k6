# 📚 4장: 고급 파이썬 기법 완전 가이드

## 🎯 학습 목표
- 리스트 컴프리헨션의 문법과 활용법 이해
- enumerate()와 zip() 함수의 사용법 학습
- 람다 함수의 개념과 활용 사례 파악
- 성능 비교를 통한 최적화 방법 이해
- 파이썬의 고급 기능들을 실무에 적용하는 방법 학습

## 📖 핵심 개념

### 1. 리스트 컴프리헨션 (List Comprehension)
**정의**: 리스트를 간결하고 효율적으로 생성하는 파이썬의 고급 문법

**기본 문법**:
```python
[표현식 for 항목 in 반복가능객체]
[표현식 for 항목 in 반복가능객체 if 조건]
```

**기존 for문과 비교**:
```python
# 기존 방식
squares = []
for x in range(1, 6):
    squares.append(x**2)

# 리스트 컴프리헨션
squares = [x**2 for x in range(1, 6)]
```

**실제 사용 예시**:
```python
# 기본 사용법
numbers = [1, 2, 3, 4, 5]
squares = [x**2 for x in numbers]
print(squares)  # [1, 4, 9, 16, 25]

# 조건문 포함
even_squares = [x**2 for x in range(1, 11) if x % 2 == 0]
print(even_squares)  # [4, 16, 36, 64, 100]

# 중첩 반복문
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flattened = [element for row in matrix for element in row]
print(flattened)  # [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

### 2. enumerate() 함수
**정의**: 반복 가능한 객체를 순회하면서 인덱스와 값을 동시에 가져오는 함수

**기본 문법**:
```python
enumerate(반복가능객체, 시작값=0)
```

**실제 사용 예시**:
```python
# 기본 사용법
fruits = ["사과", "바나나", "체리"]
for index, fruit in enumerate(fruits):
    print(f"{index}: {fruit}")

# 시작값 지정
for index, fruit in enumerate(fruits, 1):
    print(f"{index}번째: {fruit}")

# 딕셔너리 생성
fruit_dict = {index: fruit for index, fruit in enumerate(fruits)}
print(fruit_dict)  # {0: '사과', 1: '바나나', 2: '체리'}
```

### 3. zip() 함수
**정의**: 여러 개의 반복 가능한 객체를 동시에 순회하는 함수

**기본 문법**:
```python
zip(반복가능객체1, 반복가능객체2, ...)
```

**실제 사용 예시**:
```python
# 기본 사용법
names = ["철수", "영희", "민수"]
ages = [25, 30, 35]
cities = ["서울", "부산", "대구"]

for name, age, city in zip(names, ages, cities):
    print(f"{name}은(는) {age}세이고 {city}에 살고 있습니다.")

# 딕셔너리 생성
people = {name: {"age": age, "city": city} 
          for name, age, city in zip(names, ages, cities)}
print(people)

# 리스트로 변환
zipped = list(zip(names, ages, cities))
print(zipped)  # [('철수', 25, '서울'), ('영희', 30, '부산'), ('민수', 35, '대구')]
```

### 4. 람다 함수 (Lambda Function)
**정의**: 이름 없이 정의되는 간단한 함수

**기본 문법**:
```python
lambda 매개변수: 표현식
```

**실제 사용 예시**:
```python
# 기본 사용법
add = lambda x, y: x + y
print(add(3, 5))  # 8

# map()과 함께 사용
numbers = [1, 2, 3, 4, 5]
squares = list(map(lambda x: x**2, numbers))
print(squares)  # [1, 4, 9, 16, 25]

# filter()와 함께 사용
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)  # [2, 4]

# sorted()와 함께 사용
students = [("철수", 85), ("영희", 92), ("민수", 78)]
sorted_students = sorted(students, key=lambda student: student[1], reverse=True)
print(sorted_students)  # [('영희', 92), ('철수', 85), ('민수', 78)]
```

### 5. 성능 비교와 최적화

#### 5.1 리스트 컴프리헨션 vs for문
```python
import time

# 성능 테스트
def test_performance():
    n = 1000000
    
    # for문 방식
    start_time = time.time()
    result_for = []
    for i in range(n):
        result_for.append(i**2)
    for_time = time.time() - start_time
    
    # 리스트 컴프리헨션 방식
    start_time = time.time()
    result_comp = [i**2 for i in range(n)]
    comp_time = time.time() - start_time
    
    print(f"For문 시간: {for_time:.4f}초")
    print(f"컴프리헨션 시간: {comp_time:.4f}초")
    print(f"성능 향상: {for_time/comp_time:.2f}배")

test_performance()
```

#### 5.2 메모리 효율성
```python
# 제너레이터 표현식 (메모리 효율적)
squares_gen = (x**2 for x in range(1000000))  # 제너레이터
squares_list = [x**2 for x in range(1000000)]  # 리스트

print(f"제너레이터 메모리: {squares_gen.__sizeof__()} bytes")
print(f"리스트 메모리: {squares_list.__sizeof__()} bytes")
```

## 🔧 실습 예제

### 예제 1: 리스트 컴프리헨션 활용
```python
def process_data(data):
    """데이터 처리 및 변환"""
    # 1. 숫자만 필터링하고 제곱
    squares = [x**2 for x in data if isinstance(x, (int, float))]
    
    # 2. 문자열을 대문자로 변환
    upper_strings = [s.upper() for s in data if isinstance(s, str)]
    
    # 3. 길이가 3 이상인 문자열만 필터링
    long_strings = [s for s in data if isinstance(s, str) and len(s) >= 3]
    
    return {
        "squares": squares,
        "upper_strings": upper_strings,
        "long_strings": long_strings
    }

# 사용
data = [1, "hello", 2.5, "hi", 3, "world", "a"]
result = process_data(data)
print(result)
```

### 예제 2: enumerate()와 zip() 조합
```python
def create_report(students, scores, subjects):
    """학생 성적 보고서 생성"""
    print("=== 성적 보고서 ===")
    
    for i, (name, score, subject) in enumerate(zip(students, scores, subjects), 1):
        grade = "A" if score >= 90 else "B" if score >= 80 else "C" if score >= 70 else "F"
        print(f"{i}. {name}: {subject} {score}점 ({grade})")

# 사용
students = ["철수", "영희", "민수", "지수"]
scores = [85, 92, 78, 88]
subjects = ["수학", "영어", "과학", "국어"]

create_report(students, scores, subjects)
```

### 예제 3: 람다 함수를 이용한 데이터 처리
```python
def analyze_numbers(numbers):
    """숫자 리스트 분석"""
    # 통계 계산
    total = sum(numbers)
    average = total / len(numbers)
    
    # 람다 함수로 필터링
    even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
    odd_numbers = list(filter(lambda x: x % 2 == 1, numbers))
    
    # 람다 함수로 변환
    doubled = list(map(lambda x: x * 2, numbers))
    squared = list(map(lambda x: x**2, numbers))
    
    return {
        "total": total,
        "average": average,
        "even": even_numbers,
        "odd": odd_numbers,
        "doubled": doubled,
        "squared": squared
    }

# 사용
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
result = analyze_numbers(numbers)
print(result)
```

### 예제 4: 복잡한 리스트 컴프리헨션
```python
def matrix_operations(matrix):
    """행렬 연산"""
    # 1. 대각선 요소들
    diagonal = [matrix[i][i] for i in range(min(len(matrix), len(matrix[0])))]
    
    # 2. 각 행의 합
    row_sums = [sum(row) for row in matrix]
    
    # 3. 각 열의 합
    col_sums = [sum(matrix[i][j] for i in range(len(matrix))) 
                for j in range(len(matrix[0]))]
    
    # 4. 5보다 큰 요소들
    large_elements = [element for row in matrix for element in row if element > 5]
    
    return {
        "diagonal": diagonal,
        "row_sums": row_sums,
        "col_sums": col_sums,
        "large_elements": large_elements
    }

# 사용
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
result = matrix_operations(matrix)
print(result)
```

### 예제 5: 실무 활용 예제
```python
def process_sales_data(sales_data):
    """매출 데이터 처리"""
    # 1. 월별 매출 합계
    monthly_sales = {}
    for date, amount in sales_data:
        month = date.split('-')[1]  # YYYY-MM-DD에서 MM 추출
        monthly_sales[month] = monthly_sales.get(month, 0) + amount
    
    # 2. 상위 3개 월 찾기
    top_months = sorted(monthly_sales.items(), key=lambda x: x[1], reverse=True)[:3]
    
    # 3. 평균 매출 계산
    average_sales = sum(monthly_sales.values()) / len(monthly_sales)
    
    # 4. 평균 이상인 월들
    above_average = [month for month, sales in monthly_sales.items() 
                     if sales > average_sales]
    
    return {
        "monthly_sales": monthly_sales,
        "top_months": top_months,
        "average_sales": average_sales,
        "above_average_months": above_average
    }

# 사용
sales_data = [
    ("2024-01-15", 1000),
    ("2024-01-20", 1500),
    ("2024-02-10", 2000),
    ("2024-02-25", 1200),
    ("2024-03-05", 1800),
    ("2024-03-20", 2200)
]

result = process_sales_data(sales_data)
print(result)
```

## ⚠️ 주의사항

1. **리스트 컴프리헨션의 가독성**:
   - 너무 복잡하면 일반 for문이 더 읽기 쉬울 수 있음
   - 중첩이 2단계 이상이면 주의

2. **람다 함수의 제한**:
   - 한 줄의 표현식만 가능
   - 복잡한 로직은 일반 함수 사용 권장

3. **메모리 사용량**:
   - 대용량 데이터에서는 제너레이터 표현식 고려
   - `()` 사용: 제너레이터, `[]` 사용: 리스트

4. **성능 최적화**:
   - 미리 성능을 측정하고 최적화
   - 가독성과 성능의 균형 고려

5. **enumerate()와 zip()**:
   - 길이가 다른 객체들을 zip할 때는 짧은 것 기준
   - 빈 객체를 zip하면 빈 결과

## 🎯 학습 체크리스트

- [ ] 리스트 컴프리헨션으로 간결한 코드 작성하기
- [ ] enumerate()로 인덱스와 값을 동시에 처리하기
- [ ] zip()으로 여러 리스트를 동시에 순회하기
- [ ] 람다 함수로 간단한 연산 정의하기
- [ ] map(), filter(), sorted()와 람다 함수 조합하기
- [ ] 성능 비교를 통한 최적화 방법 이해하기
- [ ] 복잡한 데이터 처리에 고급 기법 적용하기
- [ ] 가독성과 성능의 균형 고려하기

## 🔗 관련 링크

- [파이썬 공식 문서 - 리스트 컴프리헨션](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)
- [파이썬 공식 문서 - 내장 함수](https://docs.python.org/3/library/functions.html)
- [이전 챕터: 자료구조 심화](./03-자료구조심화.md)
- [다음 챕터: 객체지향 프로그래밍](./05-객체지향프로그래밍.md)
